{"ast":null,"code":"//     (c) 2012-2018 Airbnb, Inc.\n//\n//     polyglot.js may be freely distributed under the terms of the BSD\n//     license. For all licensing information, details, and documentation:\n//     http://airbnb.github.com/polyglot.js\n//\n//\n// Polyglot.js is an I18n helper library written in JavaScript, made to\n// work both in the browser and in Node. It provides a simple solution for\n// interpolation and pluralization, based off of Airbnb's\n// experience adding I18n functionality to its Backbone.js and Node apps.\n//\n// Polylglot is agnostic to your translation backend. It doesn't perform any\n// translation; it simply gives you a way to manage translated phrases from\n// your client- or server-side JavaScript application.\n//\n\n'use strict';\n\nvar entries = require('object.entries');\nvar warning = require('warning');\nvar has = require('hasown');\nvar warn = function warn(message) {\n  warning(false, message);\n};\nvar defaultReplace = String.prototype.replace;\nvar split = String.prototype.split;\n\n// #### Pluralization methods\n// The string that separates the different phrase possibilities.\nvar delimiter = '||||';\nvar russianPluralGroups = function (n) {\n  var lastTwo = n % 100;\n  var end = lastTwo % 10;\n  if (lastTwo !== 11 && end === 1) {\n    return 0;\n  }\n  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n    return 1;\n  }\n  return 2;\n};\nvar defaultPluralRules = {\n  // Mapping from pluralization group plural logic.\n  pluralTypes: {\n    arabic: function (n) {\n      // http://www.arabeyes.org/Plural_Forms\n      if (n < 3) {\n        return n;\n      }\n      var lastTwo = n % 100;\n      if (lastTwo >= 3 && lastTwo <= 10) return 3;\n      return lastTwo >= 11 ? 4 : 5;\n    },\n    bosnian_serbian: russianPluralGroups,\n    chinese: function () {\n      return 0;\n    },\n    croatian: russianPluralGroups,\n    french: function (n) {\n      return n >= 2 ? 1 : 0;\n    },\n    german: function (n) {\n      return n !== 1 ? 1 : 0;\n    },\n    russian: russianPluralGroups,\n    lithuanian: function (n) {\n      if (n % 10 === 1 && n % 100 !== 11) {\n        return 0;\n      }\n      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;\n    },\n    czech: function (n) {\n      if (n === 1) {\n        return 0;\n      }\n      return n >= 2 && n <= 4 ? 1 : 2;\n    },\n    polish: function (n) {\n      if (n === 1) {\n        return 0;\n      }\n      var end = n % 10;\n      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    icelandic: function (n) {\n      return n % 10 !== 1 || n % 100 === 11 ? 1 : 0;\n    },\n    slovenian: function (n) {\n      var lastTwo = n % 100;\n      if (lastTwo === 1) {\n        return 0;\n      }\n      if (lastTwo === 2) {\n        return 1;\n      }\n      if (lastTwo === 3 || lastTwo === 4) {\n        return 2;\n      }\n      return 3;\n    },\n    romanian: function (n) {\n      if (n === 1) {\n        return 0;\n      }\n      var lastTwo = n % 100;\n      if (n === 0 || lastTwo >= 2 && lastTwo <= 19) {\n        return 1;\n      }\n      return 2;\n    },\n    ukrainian: russianPluralGroups\n  },\n  // Mapping from pluralization group to individual language codes/locales.\n  // Will look up based on exact match, if not found and it's a locale will parse the locale\n  // for language code, and if that does not exist will default to 'en'\n  pluralTypeToLanguages: {\n    arabic: ['ar'],\n    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],\n    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],\n    croatian: ['hr', 'hr-HR'],\n    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],\n    french: ['fr', 'tl', 'pt-br'],\n    russian: ['ru', 'ru-RU'],\n    lithuanian: ['lt'],\n    czech: ['cs', 'cs-CZ', 'sk'],\n    polish: ['pl'],\n    icelandic: ['is', 'mk'],\n    slovenian: ['sl-SL'],\n    romanian: ['ro'],\n    ukrainian: ['uk', 'ua']\n  }\n};\nfunction langToTypeMap(mapping) {\n  var ret = {};\n  var mappingEntries = entries(mapping);\n  for (var i = 0; i < mappingEntries.length; i += 1) {\n    var type = mappingEntries[i][0];\n    var langs = mappingEntries[i][1];\n    for (var j = 0; j < langs.length; j += 1) {\n      ret[langs[j]] = type;\n    }\n  }\n  return ret;\n}\nfunction pluralTypeName(pluralRules, locale) {\n  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);\n  return langToPluralType[locale] || langToPluralType[split.call(locale, /-/, 1)[0]] || langToPluralType.en;\n}\nfunction pluralTypeIndex(pluralRules, pluralType, count) {\n  return pluralRules.pluralTypes[pluralType](count);\n}\nfunction createMemoizedPluralTypeNameSelector() {\n  var localePluralTypeStorage = {};\n  return function (pluralRules, locale) {\n    var pluralType = localePluralTypeStorage[locale];\n    if (pluralType && !pluralRules.pluralTypes[pluralType]) {\n      pluralType = null;\n      localePluralTypeStorage[locale] = pluralType;\n    }\n    if (!pluralType) {\n      pluralType = pluralTypeName(pluralRules, locale);\n      if (pluralType) {\n        localePluralTypeStorage[locale] = pluralType;\n      }\n    }\n    return pluralType;\n  };\n}\nfunction escape(token) {\n  return token.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction constructTokenRegex(opts) {\n  var prefix = opts && opts.prefix || '%{';\n  var suffix = opts && opts.suffix || '}';\n  if (prefix === delimiter || suffix === delimiter) {\n    throw new RangeError('\"' + delimiter + '\" token is reserved for pluralization');\n  }\n  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');\n}\nvar memoizedPluralTypeName = createMemoizedPluralTypeNameSelector();\nvar defaultTokenRegex = /%\\{(.*?)\\}/g;\n\n// ### transformPhrase(phrase, substitutions, locale)\n//\n// Takes a phrase string and transforms it by choosing the correct\n// plural form and interpolating it.\n//\n//     transformPhrase('Hello, %{name}!', {name: 'Spike'});\n//     // \"Hello, Spike!\"\n//\n// The correct plural form is selected if substitutions.smart_count\n// is set. You can pass in a number instead of an Object as `substitutions`\n// as a shortcut for `smart_count`.\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');\n//     // \"1 new message\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');\n//     // \"2 new messages\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');\n//     // \"5 new messages\"\n//\n// You should pass in a third argument, the locale, to specify the correct plural type.\n// It defaults to `'en'` with 2 plural forms.\nfunction transformPhrase(phrase, substitutions, locale, tokenRegex, pluralRules, replaceImplementation) {\n  if (typeof phrase !== 'string') {\n    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');\n  }\n  if (substitutions == null) {\n    return phrase;\n  }\n  var result = phrase;\n  var interpolationRegex = tokenRegex || defaultTokenRegex;\n  var replace = replaceImplementation || defaultReplace;\n\n  // allow number as a pluralization shortcut\n  var options = typeof substitutions === 'number' ? {\n    smart_count: substitutions\n  } : substitutions;\n\n  // Select plural form: based on a phrase text that contains `n`\n  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,\n  // choose the correct plural form. This is only done if `count` is set.\n  if (options.smart_count != null && phrase) {\n    var pluralRulesOrDefault = pluralRules || defaultPluralRules;\n    var texts = split.call(phrase, delimiter);\n    var bestLocale = locale || 'en';\n    var pluralType = memoizedPluralTypeName(pluralRulesOrDefault, bestLocale);\n    var pluralTypeWithCount = pluralTypeIndex(pluralRulesOrDefault, pluralType, options.smart_count);\n    result = defaultReplace.call(texts[pluralTypeWithCount] || texts[0], /^[^\\S]*|[^\\S]*$/g, '');\n  }\n\n  // Interpolate: Creates a `RegExp` object for each interpolation placeholder.\n  result = replace.call(result, interpolationRegex, function (expression, argument) {\n    if (!has(options, argument) || options[argument] == null) {\n      return expression;\n    }\n    return options[argument];\n  });\n  return result;\n}\n\n// ### Polyglot class constructor\nfunction Polyglot(options) {\n  var opts = options || {};\n  this.phrases = {};\n  this.extend(opts.phrases || {});\n  this.currentLocale = opts.locale || 'en';\n  var allowMissing = opts.allowMissing ? transformPhrase : null;\n  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;\n  this.warn = opts.warn || warn;\n  this.replaceImplementation = opts.replace || defaultReplace;\n  this.tokenRegex = constructTokenRegex(opts.interpolation);\n  this.pluralRules = opts.pluralRules || defaultPluralRules;\n}\n\n// ### polyglot.locale([locale])\n//\n// Get or set locale. Internally, Polyglot only uses locale for pluralization.\nPolyglot.prototype.locale = function (newLocale) {\n  if (newLocale) this.currentLocale = newLocale;\n  return this.currentLocale;\n};\n\n// ### polyglot.extend(phrases)\n//\n// Use `extend` to tell Polyglot how to translate a given key.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The key can be any string.  Feel free to call `extend` multiple times;\n// it will override any phrases with the same key, but leave existing phrases\n// untouched.\n//\n// It is also possible to pass nested phrase objects, which get flattened\n// into an object with the nested keys concatenated using dot notation.\n//\n//     polyglot.extend({\n//       \"nav\": {\n//         \"hello\": \"Hello\",\n//         \"hello_name\": \"Hello, %{name}\",\n//         \"sidebar\": {\n//           \"welcome\": \"Welcome\"\n//         }\n//       }\n//     });\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}',\n//     //   'nav.sidebar.welcome': 'Welcome'\n//     // }\n//\n// `extend` accepts an optional second argument, `prefix`, which can be used\n// to prefix every key in the phrases object with some string, using dot\n// notation.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     }, \"nav\");\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}'\n//     // }\n//\n// This feature is used internally to support nested phrase objects.\nPolyglot.prototype.extend = function (morePhrases, prefix) {\n  var phraseEntries = entries(morePhrases || {});\n  for (var i = 0; i < phraseEntries.length; i += 1) {\n    var key = phraseEntries[i][0];\n    var phrase = phraseEntries[i][1];\n    var prefixedKey = prefix ? prefix + '.' + key : key;\n    if (typeof phrase === 'object') {\n      this.extend(phrase, prefixedKey);\n    } else {\n      this.phrases[prefixedKey] = phrase;\n    }\n  }\n};\n\n// ### polyglot.unset(phrases)\n// Use `unset` to selectively remove keys from a polyglot instance.\n//\n//     polyglot.unset(\"some_key\");\n//     polyglot.unset({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The unset method can take either a string (for the key), or an object hash with\n// the keys that you would like to unset.\nPolyglot.prototype.unset = function (morePhrases, prefix) {\n  if (typeof morePhrases === 'string') {\n    delete this.phrases[morePhrases];\n  } else {\n    var phraseEntries = entries(morePhrases || {});\n    for (var i = 0; i < phraseEntries.length; i += 1) {\n      var key = phraseEntries[i][0];\n      var phrase = phraseEntries[i][1];\n      var prefixedKey = prefix ? prefix + '.' + key : key;\n      if (typeof phrase === 'object') {\n        this.unset(phrase, prefixedKey);\n      } else {\n        delete this.phrases[prefixedKey];\n      }\n    }\n  }\n};\n\n// ### polyglot.clear()\n//\n// Clears all phrases. Useful for special cases, such as freeing\n// up memory if you have lots of phrases but no longer need to\n// perform any translation. Also used internally by `replace`.\nPolyglot.prototype.clear = function () {\n  this.phrases = {};\n};\n\n// ### polyglot.replace(phrases)\n//\n// Completely replace the existing phrases with a new set of phrases.\n// Normally, just use `extend` to add more phrases, but under certain\n// circumstances, you may want to make sure no old phrases are lying around.\nPolyglot.prototype.replace = function (newPhrases) {\n  this.clear();\n  this.extend(newPhrases);\n};\n\n// ### polyglot.t(key, options)\n//\n// The most-used method. Provide a key, and `t` will return the\n// phrase.\n//\n//     polyglot.t(\"hello\");\n//     => \"Hello\"\n//\n// The phrase value is provided first by a call to `polyglot.extend()` or\n// `polyglot.replace()`.\n//\n// Pass in an object as the second argument to perform interpolation.\n//\n//     polyglot.t(\"hello_name\", {name: \"Spike\"});\n//     => \"Hello, Spike\"\n//\n// If you like, you can provide a default value in case the phrase is missing.\n// Use the special option key \"_\" to specify a default.\n//\n//     polyglot.t(\"i_like_to_write_in_language\", {\n//       _: \"I like to write in %{language}.\",\n//       language: \"JavaScript\"\n//     });\n//     => \"I like to write in JavaScript.\"\n//\nPolyglot.prototype.t = function (key, options) {\n  var phrase, result;\n  var opts = options == null ? {} : options;\n  if (typeof this.phrases[key] === 'string') {\n    phrase = this.phrases[key];\n  } else if (typeof opts._ === 'string') {\n    phrase = opts._;\n  } else if (this.onMissingKey) {\n    var onMissingKey = this.onMissingKey;\n    result = onMissingKey(key, opts, this.currentLocale, this.tokenRegex, this.pluralRules, this.replaceImplementation);\n  } else {\n    this.warn('Missing translation for key: \"' + key + '\"');\n    result = key;\n  }\n  if (typeof phrase === 'string') {\n    result = transformPhrase(phrase, opts, this.currentLocale, this.tokenRegex, this.pluralRules, this.replaceImplementation);\n  }\n  return result;\n};\n\n// ### polyglot.has(key)\n//\n// Check if polyglot has a translation for given key\nPolyglot.prototype.has = function (key) {\n  return has(this.phrases, key);\n};\n\n// export transformPhrase\nPolyglot.transformPhrase = function transform(phrase, substitutions, locale) {\n  return transformPhrase(phrase, substitutions, locale);\n};\nmodule.exports = Polyglot;","map":{"version":3,"names":["entries","require","warning","has","warn","message","defaultReplace","String","prototype","replace","split","delimiter","russianPluralGroups","n","lastTwo","end","defaultPluralRules","pluralTypes","arabic","bosnian_serbian","chinese","croatian","french","german","russian","lithuanian","czech","polish","icelandic","slovenian","romanian","ukrainian","pluralTypeToLanguages","langToTypeMap","mapping","ret","mappingEntries","i","length","type","langs","j","pluralTypeName","pluralRules","locale","langToPluralType","call","en","pluralTypeIndex","pluralType","count","createMemoizedPluralTypeNameSelector","localePluralTypeStorage","escape","token","constructTokenRegex","opts","prefix","suffix","RangeError","RegExp","memoizedPluralTypeName","defaultTokenRegex","transformPhrase","phrase","substitutions","tokenRegex","replaceImplementation","TypeError","result","interpolationRegex","options","smart_count","pluralRulesOrDefault","texts","bestLocale","pluralTypeWithCount","expression","argument","Polyglot","phrases","extend","currentLocale","allowMissing","onMissingKey","interpolation","newLocale","morePhrases","phraseEntries","key","prefixedKey","unset","clear","newPhrases","t","_","transform","module","exports"],"sources":["/home/agrima/Desktop/curr-projects/Shift-Smart/webapp/src/main/frontend/node_modules/node-polyglot/index.js"],"sourcesContent":["//     (c) 2012-2018 Airbnb, Inc.\n//\n//     polyglot.js may be freely distributed under the terms of the BSD\n//     license. For all licensing information, details, and documentation:\n//     http://airbnb.github.com/polyglot.js\n//\n//\n// Polyglot.js is an I18n helper library written in JavaScript, made to\n// work both in the browser and in Node. It provides a simple solution for\n// interpolation and pluralization, based off of Airbnb's\n// experience adding I18n functionality to its Backbone.js and Node apps.\n//\n// Polylglot is agnostic to your translation backend. It doesn't perform any\n// translation; it simply gives you a way to manage translated phrases from\n// your client- or server-side JavaScript application.\n//\n\n'use strict';\n\nvar entries = require('object.entries');\nvar warning = require('warning');\nvar has = require('hasown');\n\nvar warn = function warn(message) {\n  warning(false, message);\n};\n\nvar defaultReplace = String.prototype.replace;\nvar split = String.prototype.split;\n\n// #### Pluralization methods\n// The string that separates the different phrase possibilities.\nvar delimiter = '||||';\n\nvar russianPluralGroups = function (n) {\n  var lastTwo = n % 100;\n  var end = lastTwo % 10;\n  if (lastTwo !== 11 && end === 1) {\n    return 0;\n  }\n  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n    return 1;\n  }\n  return 2;\n};\n\nvar defaultPluralRules = {\n  // Mapping from pluralization group plural logic.\n  pluralTypes: {\n    arabic: function (n) {\n      // http://www.arabeyes.org/Plural_Forms\n      if (n < 3) { return n; }\n      var lastTwo = n % 100;\n      if (lastTwo >= 3 && lastTwo <= 10) return 3;\n      return lastTwo >= 11 ? 4 : 5;\n    },\n    bosnian_serbian: russianPluralGroups,\n    chinese: function () { return 0; },\n    croatian: russianPluralGroups,\n    french: function (n) { return n >= 2 ? 1 : 0; },\n    german: function (n) { return n !== 1 ? 1 : 0; },\n    russian: russianPluralGroups,\n    lithuanian: function (n) {\n      if (n % 10 === 1 && n % 100 !== 11) { return 0; }\n      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;\n    },\n    czech: function (n) {\n      if (n === 1) { return 0; }\n      return (n >= 2 && n <= 4) ? 1 : 2;\n    },\n    polish: function (n) {\n      if (n === 1) { return 0; }\n      var end = n % 10;\n      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    icelandic: function (n) { return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0; },\n    slovenian: function (n) {\n      var lastTwo = n % 100;\n      if (lastTwo === 1) {\n        return 0;\n      }\n      if (lastTwo === 2) {\n        return 1;\n      }\n      if (lastTwo === 3 || lastTwo === 4) {\n        return 2;\n      }\n      return 3;\n    },\n    romanian: function (n) {\n      if (n === 1) { return 0; }\n      var lastTwo = n % 100;\n      if (n === 0 || (lastTwo >= 2 && lastTwo <= 19)) { return 1; }\n      return 2;\n    },\n    ukrainian: russianPluralGroups\n  },\n\n  // Mapping from pluralization group to individual language codes/locales.\n  // Will look up based on exact match, if not found and it's a locale will parse the locale\n  // for language code, and if that does not exist will default to 'en'\n  pluralTypeToLanguages: {\n    arabic: ['ar'],\n    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],\n    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],\n    croatian: ['hr', 'hr-HR'],\n    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],\n    french: ['fr', 'tl', 'pt-br'],\n    russian: ['ru', 'ru-RU'],\n    lithuanian: ['lt'],\n    czech: ['cs', 'cs-CZ', 'sk'],\n    polish: ['pl'],\n    icelandic: ['is', 'mk'],\n    slovenian: ['sl-SL'],\n    romanian: ['ro'],\n    ukrainian: ['uk', 'ua']\n  }\n};\n\nfunction langToTypeMap(mapping) {\n  var ret = {};\n  var mappingEntries = entries(mapping);\n  for (var i = 0; i < mappingEntries.length; i += 1) {\n    var type = mappingEntries[i][0];\n    var langs = mappingEntries[i][1];\n    for (var j = 0; j < langs.length; j += 1) {\n      ret[langs[j]] = type;\n    }\n  }\n  return ret;\n}\n\nfunction pluralTypeName(pluralRules, locale) {\n  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);\n  return langToPluralType[locale]\n    || langToPluralType[split.call(locale, /-/, 1)[0]]\n    || langToPluralType.en;\n}\n\nfunction pluralTypeIndex(pluralRules, pluralType, count) {\n  return pluralRules.pluralTypes[pluralType](count);\n}\n\nfunction createMemoizedPluralTypeNameSelector() {\n  var localePluralTypeStorage = {};\n\n  return function (pluralRules, locale) {\n    var pluralType = localePluralTypeStorage[locale];\n\n    if (pluralType && !pluralRules.pluralTypes[pluralType]) {\n      pluralType = null;\n      localePluralTypeStorage[locale] = pluralType;\n    }\n\n    if (!pluralType) {\n      pluralType = pluralTypeName(pluralRules, locale);\n\n      if (pluralType) {\n        localePluralTypeStorage[locale] = pluralType;\n      }\n    }\n\n    return pluralType;\n  };\n}\n\nfunction escape(token) {\n  return token.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction constructTokenRegex(opts) {\n  var prefix = (opts && opts.prefix) || '%{';\n  var suffix = (opts && opts.suffix) || '}';\n\n  if (prefix === delimiter || suffix === delimiter) {\n    throw new RangeError('\"' + delimiter + '\" token is reserved for pluralization');\n  }\n\n  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');\n}\n\nvar memoizedPluralTypeName = createMemoizedPluralTypeNameSelector();\n\nvar defaultTokenRegex = /%\\{(.*?)\\}/g;\n\n// ### transformPhrase(phrase, substitutions, locale)\n//\n// Takes a phrase string and transforms it by choosing the correct\n// plural form and interpolating it.\n//\n//     transformPhrase('Hello, %{name}!', {name: 'Spike'});\n//     // \"Hello, Spike!\"\n//\n// The correct plural form is selected if substitutions.smart_count\n// is set. You can pass in a number instead of an Object as `substitutions`\n// as a shortcut for `smart_count`.\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');\n//     // \"1 new message\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');\n//     // \"2 new messages\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');\n//     // \"5 new messages\"\n//\n// You should pass in a third argument, the locale, to specify the correct plural type.\n// It defaults to `'en'` with 2 plural forms.\nfunction transformPhrase(\n  phrase,\n  substitutions,\n  locale,\n  tokenRegex,\n  pluralRules,\n  replaceImplementation\n) {\n  if (typeof phrase !== 'string') {\n    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');\n  }\n\n  if (substitutions == null) {\n    return phrase;\n  }\n\n  var result = phrase;\n  var interpolationRegex = tokenRegex || defaultTokenRegex;\n  var replace = replaceImplementation || defaultReplace;\n\n  // allow number as a pluralization shortcut\n  var options = typeof substitutions === 'number' ? { smart_count: substitutions } : substitutions;\n\n  // Select plural form: based on a phrase text that contains `n`\n  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,\n  // choose the correct plural form. This is only done if `count` is set.\n  if (options.smart_count != null && phrase) {\n    var pluralRulesOrDefault = pluralRules || defaultPluralRules;\n    var texts = split.call(phrase, delimiter);\n    var bestLocale = locale || 'en';\n    var pluralType = memoizedPluralTypeName(pluralRulesOrDefault, bestLocale);\n    var pluralTypeWithCount = pluralTypeIndex(\n      pluralRulesOrDefault,\n      pluralType,\n      options.smart_count\n    );\n\n    result = defaultReplace.call(texts[pluralTypeWithCount] || texts[0], /^[^\\S]*|[^\\S]*$/g, '');\n  }\n\n  // Interpolate: Creates a `RegExp` object for each interpolation placeholder.\n  result = replace.call(result, interpolationRegex, function (expression, argument) {\n    if (!has(options, argument) || options[argument] == null) { return expression; }\n    return options[argument];\n  });\n\n  return result;\n}\n\n// ### Polyglot class constructor\nfunction Polyglot(options) {\n  var opts = options || {};\n  this.phrases = {};\n  this.extend(opts.phrases || {});\n  this.currentLocale = opts.locale || 'en';\n  var allowMissing = opts.allowMissing ? transformPhrase : null;\n  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;\n  this.warn = opts.warn || warn;\n  this.replaceImplementation = opts.replace || defaultReplace;\n  this.tokenRegex = constructTokenRegex(opts.interpolation);\n  this.pluralRules = opts.pluralRules || defaultPluralRules;\n}\n\n// ### polyglot.locale([locale])\n//\n// Get or set locale. Internally, Polyglot only uses locale for pluralization.\nPolyglot.prototype.locale = function (newLocale) {\n  if (newLocale) this.currentLocale = newLocale;\n  return this.currentLocale;\n};\n\n// ### polyglot.extend(phrases)\n//\n// Use `extend` to tell Polyglot how to translate a given key.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The key can be any string.  Feel free to call `extend` multiple times;\n// it will override any phrases with the same key, but leave existing phrases\n// untouched.\n//\n// It is also possible to pass nested phrase objects, which get flattened\n// into an object with the nested keys concatenated using dot notation.\n//\n//     polyglot.extend({\n//       \"nav\": {\n//         \"hello\": \"Hello\",\n//         \"hello_name\": \"Hello, %{name}\",\n//         \"sidebar\": {\n//           \"welcome\": \"Welcome\"\n//         }\n//       }\n//     });\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}',\n//     //   'nav.sidebar.welcome': 'Welcome'\n//     // }\n//\n// `extend` accepts an optional second argument, `prefix`, which can be used\n// to prefix every key in the phrases object with some string, using dot\n// notation.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     }, \"nav\");\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}'\n//     // }\n//\n// This feature is used internally to support nested phrase objects.\nPolyglot.prototype.extend = function (morePhrases, prefix) {\n  var phraseEntries = entries(morePhrases || {});\n  for (var i = 0; i < phraseEntries.length; i += 1) {\n    var key = phraseEntries[i][0];\n    var phrase = phraseEntries[i][1];\n    var prefixedKey = prefix ? prefix + '.' + key : key;\n    if (typeof phrase === 'object') {\n      this.extend(phrase, prefixedKey);\n    } else {\n      this.phrases[prefixedKey] = phrase;\n    }\n  }\n};\n\n// ### polyglot.unset(phrases)\n// Use `unset` to selectively remove keys from a polyglot instance.\n//\n//     polyglot.unset(\"some_key\");\n//     polyglot.unset({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The unset method can take either a string (for the key), or an object hash with\n// the keys that you would like to unset.\nPolyglot.prototype.unset = function (morePhrases, prefix) {\n  if (typeof morePhrases === 'string') {\n    delete this.phrases[morePhrases];\n  } else {\n    var phraseEntries = entries(morePhrases || {});\n    for (var i = 0; i < phraseEntries.length; i += 1) {\n      var key = phraseEntries[i][0];\n      var phrase = phraseEntries[i][1];\n      var prefixedKey = prefix ? prefix + '.' + key : key;\n      if (typeof phrase === 'object') {\n        this.unset(phrase, prefixedKey);\n      } else {\n        delete this.phrases[prefixedKey];\n      }\n    }\n  }\n};\n\n// ### polyglot.clear()\n//\n// Clears all phrases. Useful for special cases, such as freeing\n// up memory if you have lots of phrases but no longer need to\n// perform any translation. Also used internally by `replace`.\nPolyglot.prototype.clear = function () {\n  this.phrases = {};\n};\n\n// ### polyglot.replace(phrases)\n//\n// Completely replace the existing phrases with a new set of phrases.\n// Normally, just use `extend` to add more phrases, but under certain\n// circumstances, you may want to make sure no old phrases are lying around.\nPolyglot.prototype.replace = function (newPhrases) {\n  this.clear();\n  this.extend(newPhrases);\n};\n\n// ### polyglot.t(key, options)\n//\n// The most-used method. Provide a key, and `t` will return the\n// phrase.\n//\n//     polyglot.t(\"hello\");\n//     => \"Hello\"\n//\n// The phrase value is provided first by a call to `polyglot.extend()` or\n// `polyglot.replace()`.\n//\n// Pass in an object as the second argument to perform interpolation.\n//\n//     polyglot.t(\"hello_name\", {name: \"Spike\"});\n//     => \"Hello, Spike\"\n//\n// If you like, you can provide a default value in case the phrase is missing.\n// Use the special option key \"_\" to specify a default.\n//\n//     polyglot.t(\"i_like_to_write_in_language\", {\n//       _: \"I like to write in %{language}.\",\n//       language: \"JavaScript\"\n//     });\n//     => \"I like to write in JavaScript.\"\n//\nPolyglot.prototype.t = function (key, options) {\n  var phrase, result;\n  var opts = options == null ? {} : options;\n  if (typeof this.phrases[key] === 'string') {\n    phrase = this.phrases[key];\n  } else if (typeof opts._ === 'string') {\n    phrase = opts._;\n  } else if (this.onMissingKey) {\n    var onMissingKey = this.onMissingKey;\n    result = onMissingKey(\n      key,\n      opts,\n      this.currentLocale,\n      this.tokenRegex,\n      this.pluralRules,\n      this.replaceImplementation\n    );\n  } else {\n    this.warn('Missing translation for key: \"' + key + '\"');\n    result = key;\n  }\n  if (typeof phrase === 'string') {\n    result = transformPhrase(\n      phrase,\n      opts,\n      this.currentLocale,\n      this.tokenRegex,\n      this.pluralRules,\n      this.replaceImplementation\n    );\n  }\n  return result;\n};\n\n// ### polyglot.has(key)\n//\n// Check if polyglot has a translation for given key\nPolyglot.prototype.has = function (key) {\n  return has(this.phrases, key);\n};\n\n// export transformPhrase\nPolyglot.transformPhrase = function transform(phrase, substitutions, locale) {\n  return transformPhrase(phrase, substitutions, locale);\n};\n\nmodule.exports = Polyglot;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}